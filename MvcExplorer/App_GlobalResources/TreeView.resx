<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Accordion_Text0" xml:space="preserve">
    <value>This view shows how to make an Accordion control using TreeView control.</value>
  </data>
  <data name="Accordion_Text1" xml:space="preserve">
    <value>Accordions are multi-pane panels that keep only one panel expanded at a time. They are commonly used for navigation.</value>
  </data>
  <data name="Accordion_Text2" xml:space="preserve">
    <value>You can use the TreeView control to implement accordions.</value>
  </data>
  <data name="Accordion_Text3" xml:space="preserve">
    <value>Use CSS to customize the header display and to hide the collapse/expand glyphs, and make sure the &lt;b&gt;AutoCollapse&lt;/b&gt; property is set to true (the default), so non-active panels are automatically collapsed.</value>
  </data>
  <data name="Checkboxes_Text1" xml:space="preserve">
    <value>This view shows how to show checkboxes in a TreeView control.</value>
  </data>
  <data name="Checkboxes_Text2" xml:space="preserve">
    <value>Set the &lt;b&gt;ShowCheckboxes&lt;/b&gt; property to true and the TreeView will add checkboxes to each node.</value>
  </data>
  <data name="Checkboxes_Text3" xml:space="preserve">
    <value>When checkboxes are displayed, the TreeView manages their hierarchy so that when a checkbox is checked or cleared, 
        the new value is automatically applied to all child nodes, and reflected on the state of the parent nodes.</value>
  </data>
  <data name="Checkboxes_Text4" xml:space="preserve">
    <value>When items are checked or unchecked, the &lt;b&gt;OnClientCheckedItemsChanged&lt;/b&gt; event is raised, 
        and the checkedItems property of the client TreeView object is updated with a list of the items that are currently checked.</value>
  </data>
  <data name="Checkboxes_Text5" xml:space="preserve">
    <value>The checkboxes are only shown when TreeView works without lazy nodes.
        That's to say, the second parameter &lt;b&gt;LazyLoadActionUrl&lt;/b&gt; in the &lt;b&gt;Bind&lt;/b&gt; method and the &lt;b&gt;OnClientLazyLoadFunction&lt;/b&gt; property are not set.</value>
  </data>
  <data name="CustomNodeContent_Text0" xml:space="preserve">
    <value>This view shows how to customize the node content in a TreeView control.</value>
  </data>
  <data name="CustomNodeContent_Text1" xml:space="preserve">
    <value>You can customize the content of the TreeView nodes using the formatItem event. The event handler parameters include the element that represents the node and the data item being rendered.</value>
  </data>
  <data name="CustomNodeContent_Text2" xml:space="preserve">
    <value>The example uses the &lt;b&gt;OnClientFormatItem&lt;/b&gt; event to add a "new" badge to the right of new items on the tree.</value>
  </data>
  <data name="DragDrop_Text0" xml:space="preserve">
    <value>This view shows how to drag and drop the nodes in a TreeView control.</value>
  </data>
  <data name="DragDrop_Text1" xml:space="preserve">
    <value>Set the &lt;b&gt;AllowDragging&lt;/b&gt; property to true to allow users to drag nodes to new positions within the TreeView.</value>
  </data>
  <data name="DragDrop_Text2" xml:space="preserve">
    <value>When dragging is allowed, users may drag any node to any position within the tree. You can customize this behavior by handling the TreeView drag/drop events:
        &lt;ul class="normal"&gt;
            &lt;li&gt;&lt;b&gt;OnClientDragStart&lt;/b&gt;:&lt;/li&gt;
            Occurs when a drag/drop operation is about to start. You may examine the node about to be dragged and cancel the operation by setting the event's cancel parameter to true.
            &lt;li&gt;&lt;b&gt;OnClientDragOver&lt;/b&gt;:&lt;/li&gt;
            Occurs while the user drags the node over other nodes on the tree. You may examine the current target node and drop position and prevent the drop or modify its location setting the event's cancel and position parameters.
            &lt;li&gt;&lt;b&gt;OnClientDrop&lt;/b&gt;:&lt;/li&gt;
            Occurs when the user drops the node into its new location. You may examine the current target node and drop position and prevent the drop or modify its location setting the event's cancel and position parameters.
            &lt;li&gt;&lt;b&gt;OnClientDragEnd&lt;/b&gt;:&lt;/li&gt;
            Occurs after the drag/drop operation is finished, even if it was canceled and the source node was not moved.
        &lt;/ul&gt;</value>
  </data>
  <data name="DragDrop_Text3" xml:space="preserve">
    <value>The example shows how to provide standard and customized drag/drop operations on a TreeView control.</value>
  </data>
  <data name="EditingNodes_Text0" xml:space="preserve">
    <value>This view shows how to edit the nodes in a TreeView control.</value>
  </data>
  <data name="EditingNodes_Text1" xml:space="preserve">
    <value>The TreeView control provides editing support. Set the &lt;b&gt;IsReadOnly&lt;/b&gt; property to false and users will be able to edit the content of the nodes by pressing the F2 key.</value>
  </data>
  <data name="EditingNodes_Text2" xml:space="preserve">
    <value>Edits made to node contents are automatically applied to the items in the &lt;b&gt;Source&lt;/b&gt; array using the properties specified by the &lt;b&gt;DisplayMemberPath&lt;/b&gt; property.</value>
  </data>
  <data name="EditingNodes_Text3" xml:space="preserve">
    <value>You may customize the editing behavior using the following events: OnClientNodeEditStarting, OnClientNodeEditStarted, OnClientNodeEditEnding, and OnClientNodeEditEnded.</value>
  </data>
  <data name="EditingNodes_Text4" xml:space="preserve">
    <value>In the example below, we enable editing only for nodes that contain no children. To edit, select a node and press F2.</value>
  </data>
  <data name="Images_Text0" xml:space="preserve">
    <value>This view shows how to add images to the nodes in a TreeView control.</value>
  </data>
  <data name="Images_Text1" xml:space="preserve">
    <value>Use the &lt;b&gt;ImageMemberPath&lt;/b&gt; property to add images to nodes by specifying the name of a property on the data items that contains an image URL.</value>
  </data>
  <data name="Images_Text2" xml:space="preserve">
    <value>In this sample, the source contains the Image field, which value is an image url.
        "Image" is set to the &lt;b&gt;ImageMemberPath&lt;/b&gt; property.</value>
  </data>
  <data name="Index_Text0" xml:space="preserve">
    <value>This view shows basic features of TreeView for ASP.NET MVC.</value>
  </data>
  <data name="Index_Text1" xml:space="preserve">
    <value>The TreeView control displays a hierarchical list which may contain text, checkboxes, images, or arbitrary HTML content.
        A TreeView is typically used to display the headings in a document,
        the entries in an index, the files and directories on a disk,
        or any other kind of information that might usefully be displayed as a hierarchy.</value>
  </data>
  <data name="Index_Text2" xml:space="preserve">
    <value>To create trees, you will normally have to set three properties:
        &lt;ul class="normal"&gt;
            &lt;li&gt;&lt;b&gt;Source&lt;/b&gt;&lt;/li&gt;
            It is an array that contains the hierarchical data. Each item in the array contains information about a node and (optionally) an array of child nodes.
            &lt;li&gt;&lt;b&gt;DisplayMemberPath&lt;/b&gt;&lt;/li&gt;
            It defines the name of the property in the items that contains the text to be displayed in the tree nodes. By default, this property is set to the string 'header'.
            &lt;li&gt;&lt;b&gt;ChildItemsPath&lt;/b&gt;&lt;/li&gt;
            It defines the name of the property in the items that contains the array of child nodes. By default, this property is set to the string 'items'.
        &lt;/ul&gt;
    </value>
  </data>
  <data name="Index_Text3" xml:space="preserve">
    <value>There are also properties for binding node images, checkboxes the &lt;b&gt;Source&lt;/b&gt; array: &lt;b&gt;ImageMemberPath, CheckedMemberPath&lt;/b&gt; and properties for controlling treeview behavior: &lt;b&gt;IsAnimated, AutoCollapse, ExpandOnClick, CollapseOnClick, ExpandOnLoad, CollapseWhenDisabled&lt;/b&gt;.</value>
  </data>
  <data name="LazyLoading_Text0" xml:space="preserve">
    <value>This view shows how to load the child nodes dynamically in TreeView.</value>
  </data>
  <data name="LazyLoading_Text1" xml:space="preserve">
    <value>Lazy loading is useful when you are dealing with large hierarchical data sources
        and would like to avoid the delays involved in loading the entire data set at once.</value>
  </data>
  <data name="LazyLoading_Text2" xml:space="preserve">
    <value>The TreeView control makes lazy-loading super easy.
        Only set the second parameter &lt;b&gt;LazyLoadActionUrl&lt;/b&gt; and provide a url to obtain the lazy nodes data.
        If the child node has children, you can set an empty array to the field which name is what the
        &lt;b&gt;ChildItemsPath&lt;/b&gt; property stands for.
        Otherwise, let it to be null.</value>
  </data>
  <data name="LazyLoading_Text3" xml:space="preserve">
    <value>If you wants to use lazy-loading with javascript, you can set the TreeView's &lt;b&gt;OnClientLazyLoadFunction&lt;/b&gt; property to a function to be called
        when the user expands the node. This function takes two parameters: the parent node
        and a callback function to be invoked when the data becomes available.</value>
  </data>
  <data name="LazyLoading_Text4" xml:space="preserve">
    <value>The tree in example below starts with three lazy-loaded nodes.
        When you expand them, the &lt;b&gt;OnClientLazyLoadFunction&lt;/b&gt; is invoked. The function
        uses a setTimeout to simulate an http delay and returns data for three child nodes,
        one of which is also a lazy-loaded node.</value>
  </data>
  <data name="LazyLoading_Text5" xml:space="preserve">
    <value>The example also uses some CSS to animate the node icons while they are being
        loaded.</value>
  </data>
  <data name="Navigation_Text0" xml:space="preserve">
    <value>This view shows how to do navigation in TreeView for ASP.NET MVC.</value>
  </data>
  <data name="Navigation_Text1" xml:space="preserve">
    <value>The simplest and most common use for the TreeView control is navigation. The TreeView's hierarchical structure and auto-search functionality make it easy for users to drill-down and find the items they are interested in.</value>
  </data>
  <data name="Navigation_Text2" xml:space="preserve">
    <value>You can use the &lt;b&gt;OnClientSelectedItemChanged&lt;/b&gt; or &lt;b&gt;OnClientItemClicked&lt;/b&gt; events for navigation. The difference is that &lt;b&gt;OnClientSelectedItemChanged&lt;/b&gt; occurs when the user moves the selection with the keyboard, and &lt;b&gt;OnClientItemClicked&lt;/b&gt; occurs when the user clicks an item or presses the Enter key.</value>
  </data>
  <data name="Navigation_Text3" xml:space="preserve">
    <value>This example uses the &lt;b&gt;OnClientItemClicked&lt;/b&gt; event.</value>
  </data>
  <data name="Navigation_NavigatingInfo" xml:space="preserve">
    <value>Navigating to &lt;b&gt;*** {0} ***&lt;/b&gt;</value>
  </data>
  <data name="RemoteLoading_Text0" xml:space="preserve">
    <value>This view shows how to load the node items from a remote url in TreeView for ASP.NET MVC.</value>
  </data>
  <data name="Styling_Text0" xml:space="preserve">
    <value>This view shows how to customize the appearance of TreeView for ASP.NET MVC using CSS.</value>
  </data>
  <data name="Styling_Text1" xml:space="preserve">
    <value>You can customize the appearance of the TreeView using CSS.</value>
  </data>
  <data name="Styling_Text2" xml:space="preserve">
    <value>This example changes the collapse/expand icons, uses different font sizes depending on node level, and adds a vertical bar to the left of the level one nodes.</value>
  </data>
  <data name="Checkboxes_CheckedItems" xml:space="preserve">
    <value>Checked Items:</value>
  </data>
  <data name="DragDrop_Text4" xml:space="preserve">
    <value>Allow dragging parent nodes</value>
  </data>
  <data name="DragDrop_Text5" xml:space="preserve">
    <value>Allow dropping into empty nodes</value>
  </data>
  <data name="RemoteLoading_Text1" xml:space="preserve">
    <value>You can load the node items from a remote url using the &lt;b&gt;Bind(string loadActionUrl)&lt;/b&gt; method.</value>
  </data>
  <data name="Checkboxes_Text6" xml:space="preserve">
    <value>The &lt;b&gt;CheckOnClick&lt;/b&gt; property set to 'true' enables toggling check when click on entire item, not only on checkbox.</value>
  </data>
  <data name="Checkboxes_Text7" xml:space="preserve">
    <value>The &lt;b&gt;CheckedMemberPath&lt;/b&gt; property determines which property of TreeView's data items, for example 'NewItem', being assigned by checkboxes value.</value>
  </data>
</root>