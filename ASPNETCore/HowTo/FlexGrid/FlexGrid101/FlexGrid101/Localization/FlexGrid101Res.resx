<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Project_Name_Text0" xml:space="preserve">
    <value>ASP.NET MVC FlexGrid 101</value>
  </data>
  <data name="Column_Definitions_Description_Text0" xml:space="preserve">
    <value>The Getting Started example did not define any columns, so FlexGrid generated them
            automatically.</value>
  </data>
  <data name="Column_Definitions_Description_Text1" xml:space="preserve">
    <value>This example shows how you can define the columns using the FlexGrid's &lt;b&gt;Columns&lt;/b&gt; property.</value>
  </data>
  <data name="Column_Definitions_Description_Text2" xml:space="preserve">
    <value>Specifying the columns allows you to choose which columns to show, and in what order.
            This also gives you control over each column&amp;#39;s Width, Heading, Formatting, Alignment,
            and other properties.</value>
  </data>
  <data name="Column_Definitions_Description_Text3" xml:space="preserve">
    <value>In this case, we use star sizing to set the width of the "Country" column. This tells the
            column to stretch to fill the available width of the grid so there is no empty space. On
            the "Amount" column, we set the format property to "n0",  which results in numbers with thousand separators and no decimal digits. On
            the "Discount" column, we set the format property to "p0", which results in numbers with
            percentage and no decimal digits.</value>
  </data>
  <data name="Column_Definitions_Text0" xml:space="preserve">
    <value>Column Definitions</value>
  </data>
  <data name="Conditional_Styling_Description_Text0" xml:space="preserve">
    <value>FlexGrid has an &lt;b&gt;ItemFormatter&lt;/b&gt; property that gives you complete control over
            the contents of the cells.</value>
  </data>
  <data name="Conditional_Styling_Description_Text1" xml:space="preserve">
    <value>This example uses a JavaScript function to create value ranges that return named
            colors. We then call this function in the FlexGrid's &lt;b&gt;ItemFormatter&lt;/b&gt; and pass the cell's data
            in order to conditionally set the cell's foreground color.</value>
  </data>
  <data name="Conditional_Styling_Text0" xml:space="preserve">
    <value>Conditional Styling</value>
  </data>
  <data name="Editing_Description_Text0" xml:space="preserve">
    <value>FlexGrid has built-in support for fast, in-cell editing like you find in Excel. There is no
            need to add extra columns with Edit buttons that switch between display and edit modes.</value>
  </data>
  <data name="Editing_Description_Text1" xml:space="preserve">
    <value>Users can start editing by typing into any cell. This puts the cell in quick-edit mode.
            In this mode, pressing a cursor key finishes the editing and moves the selection to a different cell.</value>
  </data>
  <data name="Editing_Description_Text2" xml:space="preserve">
    <value>Another way to start editing is by pressing F2 or by clicking a cell twice. This puts the cell in
            full-edit mode. In this mode, pressing a cursor key moves the caret within the cell text.
            To finish editing and move to another cell, the user must press the Enter, Tab, or Escape key.</value>
  </data>
  <data name="Editing_Description_Text3" xml:space="preserve">
    <value>Data is automatically coerced to the proper type when editing finishes. If the user enters invalid
            data, the edit is cancelled and the original data remains in place.</value>
  </data>
  <data name="Editing_Description_Text4" xml:space="preserve">
    <value>There are two modes for updating the data to the server.</value>
  </data>
  <data name="Editing_Description_Text5" xml:space="preserve">
    <value>By default, the update operation will be commit to the server once finishing editing.
                &lt;p&gt;
                    &lt;b&gt;Notices:&lt;/b&gt;
                    If the user wants to commit the update operation to the datasource server, the Update, Delete or Create action url should be provided.
                    And the corresponding codes used to update the datasource should be written in the corresponding action.
                &lt;/p&gt;</value>
  </data>
  <data name="Editing_Description_Text6" xml:space="preserve">
    <value>The other mode is called BatchEdit. The user can update, create or remove multiple items.
                Once these modifications are confirmed, They could be commit to the data source only once. 
                Now these modifications can be commit by the commit method of CollectionView in client side.
                The user can also commit them by sorting, paging or filtering behavior.
                &lt;p&gt;
                    &lt;b&gt;Notices:&lt;/b&gt;
                     In this mode, the BatchEdit action url should be provided and the corresponding codes used to update the datasource should be written.
                &lt;/p&gt;</value>
  </data>
  <data name="Editing_Description_Text7" xml:space="preserve">
    <value>You can disable editing at the Grid, Column, or Row levels using the &lt;b&gt;IsReadOnly&lt;/b&gt; property of the
            Grid, Column, or Row objects. In this example, we make the ID column read-only.</value>
  </data>
  <data name="Editing_Text0" xml:space="preserve">
    <value>Editing</value>
  </data>
  <data name="Filtering_Description_Text0" xml:space="preserve">
    <value>The FlexGrid supports filtering through the &lt;b&gt;Filterable&lt;/b&gt; property. To enable filtering, set the &lt;b&gt;Filterable(fl =&gt; fl.ColumnFilters()&lt;/b&gt; property.</value>
  </data>
  <data name="Filtering_Description_Text1" xml:space="preserve">
    <value>In this example, we create a filter for the ID, Country, Product, Color, Start and get the filter value from the input control.
        &lt;/p&gt;</value>
  </data>
  <data name="Filtering_Text0" xml:space="preserve">
    <value>Filtering</value>
  </data>
  <data name="Getting_Started_Text0" xml:space="preserve">
    <value>Getting Started</value>
  </data>
  <data name="Grouping_Desription_Text0" xml:space="preserve">
    <value>FlexGrid supports grouping of client side data, set the &lt;b&gt;GroupBy&lt;/b&gt; property to a column name for grouping the data according to a column.</value>
  </data>
  <data name="Grouping_Desription_Text1" xml:space="preserve">
    <value>Internally, FlexGrid supports grouping through the client side &lt;b&gt;IItemsSource&lt;/b&gt; interface. To enable grouping at client side, add one or more &lt;b&gt;GroupDescription&lt;/b&gt; objects to the
            &lt;b&gt;itemsSource.groupDescriptions&lt;/b&gt; property. It is easy to let the grid grouped by some field by calling the method GroupBy of FlexGridBuilder with the corresponding field name. And ensure that the grid's &lt;b&gt;ShowGroups&lt;/b&gt; property
            is set to true (the default value).
            &lt;b&gt;GroupDescription&lt;/b&gt; objects are flexible, allowing you to group data based on value or on grouping
            functions. The example below groups dates by year; amounts by range returning three ranges: over 5,000,
            1,000 to 5,000, 500 to 1,000, and under 500; and anything else by value. Use the menu to see the effects of each grouping.</value>
  </data>
  <data name="Grouping_Desription_Text2" xml:space="preserve">
    <value>Notice that the "Amount" column displays the totals in the group rows. We do this by
            setting the column's &lt;b&gt;Aggregate&lt;/b&gt; property to "Sum." The aggregate is automatically
            updated when you edit the values in the column.</value>
  </data>
  <data name="Grouping_Text0" xml:space="preserve">
    <value>Grouping</value>
  </data>
  <data name="Handling_Null_Values_Des_Text0" xml:space="preserve">
    <value>By default, FlexGrid allows you to enter empty values in columns of type string,
            and will not allow empty/null values in columns of any other type.</value>
  </data>
  <data name="Handling_Null_Values_Des_Text1" xml:space="preserve">
    <value>You can change this behavior using the &lt;b&gt;IsRequired&lt;/b&gt; property on grid columns.
            If you set the &lt;b&gt;IsRequired&lt;/b&gt; property to false, the grid will allow you to
            enter empty values in that column, regardless of type. Conversely, if you set
            the &lt;b&gt;IsRequired&lt;/b&gt; property to true, the grid will not allow empty values
            even in string columns.</value>
  </data>
  <data name="Handling_Null_Values_Des_Text2" xml:space="preserve">
    <value>Setting &lt;b&gt;IsRequired&lt;/b&gt; to null reverts to the default behavior (nulls allowed
            only in string columns).</value>
  </data>
  <data name="Handling_Null_Values_Des_Text3" xml:space="preserve">
    <value>The grid below reverts the default behavior. It sets &lt;b&gt;IsRequired&lt;/b&gt; to false
            for the first column, and to true for all others. You can delete content that
            is not required by entering an empty string or simply by pressing the delete
            key.</value>
  </data>
  <data name="Handling_Null_Values_Text0" xml:space="preserve">
    <value>Handling null values</value>
  </data>
  <data name="Overview_Description_Text0" xml:space="preserve">
    <value>This will create a FlexGrid with default behavior, which includes
            automatic column generation, column sorting and reordering, editing,
            and clipboard support.</value>
  </data>
  <data name="Overview_Step1_Text0" xml:space="preserve">
    <value>Create a new MVC project using the C1 ASP.NET MVC application template, in Visual Studio IDE.</value>
  </data>
  <data name="Overview_Step2_Text0" xml:space="preserve">
    <value>Add a controller and the corresponding view to the project.</value>
  </data>
  <data name="Overview_Step3_Text0" xml:space="preserve">
    <value>Initialize the FlexGrid control in view using razor syntax.</value>
  </data>
  <data name="Overview_Step4_Text0" xml:space="preserve">
    <value>(Optional) Add an appropriate CSS to customize the appearance of FlexGrid control.</value>
  </data>
  <data name="Overview_Step_Title_Text0" xml:space="preserve">
    <value>Steps for getting started with the FlexGrid control in MVC applications are as follows:</value>
  </data>
  <data name="Paging_Description_Text0" xml:space="preserve">
    <value>The FlexGrid supports paging through the &lt;b&gt;Pager&lt;/b&gt; control. To enable paging, set the &lt;b&gt;PageSize&lt;/b&gt; property to the number
            of items you want on each page, and use Pager control to bind this FlexGrid.</value>
  </data>
  <data name="Paging_Description_Text1" xml:space="preserve">
    <value>In this example, we set &lt;b&gt;PageSize&lt;/b&gt; to show 10 items per page. We add Pager control and set &lt;b&gt;Owner&lt;/b&gt; Property to the FlexGrid id,
            then we can switch pages.</value>
  </data>
  <data name="Paging_Text0" xml:space="preserve">
    <value>Paging</value>
  </data>
  <data name="Project_Description_Text0" xml:space="preserve">
    <value>This page shows how to get started with ASP.NET MVC's FlexGrid controls.</value>
  </data>
  <data name="Selection_Modes_Description_Text0" xml:space="preserve">
    <value>By default, FlexGrid allows you to select a range of cells with the mouse or keyboard,
            just like Excel. The &lt;b&gt;SelectionMode &lt;/b&gt; property allows you to change that so that you
            can select a Row, a Range of Rows, Non-Contiguous Rows (like in a List-Box), a Single Cell, a Range of Cells
            or disable selection altogether.</value>
  </data>
  <data name="Selection_Modes_Description_Text1" xml:space="preserve">
    <value>This example allows you to pick the &lt;b&gt;SelectionMode &lt;/b&gt; from a C1 ASP.NET MVC's ComboBox control.</value>
  </data>
  <data name="Selection_Modes_Text0" xml:space="preserve">
    <value>Selection Modes</value>
  </data>
  <data name="Themes_Description_Text0" xml:space="preserve">
    <value>The appearance of the FlexGrid is defined in CSS. In addition to the default theme, we
            include about a dozen professionally designed themes that customize the appearance of
            all C1 ASP.NET MVC controls to achieve a consistent, attractive look.</value>
  </data>
  <data name="Themes_Description_Text1" xml:space="preserve">
    <value>In this example, we add a "custom-flex-grid" class to the grid element and define some
            CSS rules to create a simple "black and white, no borders" theme for any grids that
            have the "custom-flex-grid" class.</value>
  </data>
  <data name="Themes_Text0" xml:space="preserve">
    <value>Themes</value>
  </data>
  <data name="Trees_and_Hierarchical_Data_Des_Text0" xml:space="preserve">
    <value>In addition to grouping, FlexGrid supports hierarchical data, that is, data with items
            that have lists of subitems. This type of hierarchical structure is very common, and is
            usually displayed in a tree-view control.</value>
  </data>
  <data name="Trees_and_Hierarchical_Data_Des_Text1" xml:space="preserve">
    <value>To use FlexGrid with hierarchical data sources, set the &lt;b&gt;ChildItemsPath&lt;/b&gt; property
            to the name of the data element that contains the child elements. The grid automatically
            scans the data and builds the tree for you.</value>
  </data>
  <data name="Trees_and_Hierarchical_Data_Text0" xml:space="preserve">
    <value>Trees and Hierarchical Data</value>
  </data>
  <data name="Result_Live_Text0" xml:space="preserve">
    <value>Result(live)</value>
  </data>
  <data name="Group_By_Text0" xml:space="preserve">
    <value>Group by</value>
  </data>
</root>