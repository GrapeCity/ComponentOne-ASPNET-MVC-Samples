<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Project_Name_Text0" xml:space="preserve">
    <value>FlexGrid入門</value>
    <comment>ASP.NET MVC FlexGrid 101</comment>
  </data>
  <data name="Column_Definitions_Description_Text0" xml:space="preserve">
    <value>「はじめに」の例では列を定義しなかったため、FlexGridが自動的に生成しました。</value>
    <comment>The Getting Started example did not define any columns, so FlexGrid generated them
            automatically.</comment>
  </data>
  <data name="Column_Definitions_Description_Text1" xml:space="preserve">
    <value>この例は、FlexGridの&lt;b&gt;Columns&lt;/b&gt;プロパティを使用して列を定義する方法を示します。</value>
    <comment>This example shows how you can define the columns using the FlexGrid's &lt;b&gt;Columns&lt;/b&gt; property.</comment>
  </data>
  <data name="Column_Definitions_Description_Text2" xml:space="preserve">
    <value>columnsを指定すると、どの列を選択してどのような順序で表示するかを決めることができます。
            これにより、各列のWidth、Heading、Formatting、Alignmentなどのプロパティを制御することもできます。</value>
    <comment>Specifying the columns allows you to choose which columns to show, and in what order.
            This also gives you control over each column&amp;#39;s Width, Heading, Formatting, Alignment,
            and other properties.</comment>
  </data>
  <data name="Column_Definitions_Description_Text3" xml:space="preserve">
    <value>この場合、スターサイズ設定を使用して「Country」列の幅を設定します。これにより、グリッドの有効幅を埋めるように列を伸ばして空きスペースがないようにします。 「Amount」列は、formatプロパティを「n0」に設定した結果、桁区切りありで小数点以下の桁数がない数字になります。 「Discount」列は、formatプロパティを「p0」に設定した結果、パーセンテージ表記で小数点以下の桁数がない数値になります。</value>
    <comment>In this case, we use star sizing to set the width of the "Country" column. This tells the
            column to stretch to fill the available width of the grid so there is no empty space. On
            the "Amount" column, we set the format property to "n0",  which results in numbers with thousand separators and no decimal digits. On
            the "Discount" column, we set the format property to "p0", which results in numbers with
            percentage and no decimal digits.</comment>
  </data>
  <data name="Column_Definitions_Text0" xml:space="preserve">
    <value>列定義</value>
    <comment>Column Definitions</comment>
  </data>
  <data name="Conditional_Styling_Description_Text0" xml:space="preserve">
    <value>FlexGridには、セルのコンテンツを全面的に制御できる&lt;b&gt;ItemFormatter&lt;/b&gt;プロパティがあります。</value>
    <comment>FlexGrid has an &lt;b&gt;ItemFormatter&lt;/b&gt; property that gives you complete control over
            the contents of the cells.</comment>
  </data>
  <data name="Conditional_Styling_Description_Text1" xml:space="preserve">
    <value>この例では、TypeScript関数を使用して、名前付きの色を返す値の範囲を作成します。 次に、この関数をFlexGridの&lt;b&gt;ItemFormatter&lt;/b&gt;で呼び出し、セルの前景色を条件に基づいて設定するためにセルのデータを渡します。</value>
    <comment>This example uses a JavaScript function to create value ranges that return named
            colors. We then call this function in the FlexGrid's &lt;b&gt;ItemFormatter&lt;/b&gt; and pass the cell's data
            in order to conditionally set the cell's foreground color.</comment>
  </data>
  <data name="Conditional_Styling_Text0" xml:space="preserve">
    <value>条件付きスタイル設定</value>
    <comment>Conditional Styling</comment>
  </data>
  <data name="Editing_Description_Text0" xml:space="preserve">
    <value>FlexGridでは、Excelにあるような高速なセル内編集が組み込みでサポートされています。 余分な列を追加して、そこに表示モードと編集モードを切り替えるための編集ボタンを置く必要はありません。</value>
    <comment>FlexGrid has built-in support for fast, in-cell editing like you find in Excel. There is no
            need to add extra columns with Edit buttons that switch between display and edit modes.</comment>
  </data>
  <data name="Editing_Description_Text1" xml:space="preserve">
    <value>ユーザーは、任意のセルでキー入力することで編集を開始できます。 これで、そのセルはクイック編集モードになります。
            このモードでは、カーソルキーを押すと編集が終了し、選択範囲が別のセルに移動します。</value>
    <comment>Users can start editing by typing into any cell. This puts the cell in quick-edit mode.
            In this mode, pressing a cursor key finishes the editing and moves the selection to a different cell.</comment>
  </data>
  <data name="Editing_Description_Text2" xml:space="preserve">
    <value>編集を開始する別の方法としては、F2を押すかセルをダブルクリックします。 これで、そのセルは完全編集モードになります。 このモードでは、カーソルキーを押すと、セルテキスト内のカレットが移動します。
            編集を終了し、別のセルに移動するには、［Enter］、［Tab］、または［Esc］キーを押す必要があります。</value>
    <comment>Another way to start editing is by pressing F2 or by clicking a cell twice. This puts the cell in
            full-edit mode. In this mode, pressing a cursor key moves the caret within the cell text.
            To finish editing and move to another cell, the user must press the Enter, Tab, or Escape key.</comment>
  </data>
  <data name="Editing_Description_Text3" xml:space="preserve">
    <value>編集が終了すると、データは自動的に適切なタイプに変換されます。 ユーザーが無効なデータを入力した場合、編集はキャンセルされ、元のデータが保持されます。</value>
    <comment>Data is automatically coerced to the proper type when editing finishes. If the user enters invalid
            data, the edit is cancelled and the original data remains in place.</comment>
  </data>
  <data name="Editing_Description_Text4" xml:space="preserve">
    <value>データをサーバーに対して更新するモードは２つあります。</value>
    <comment>There are two modes for updating the data to the server.</comment>
  </data>
  <data name="Editing_Description_Text5" xml:space="preserve">
    <value>デフォルトでは、編集が終了すると更新操作がサーバーにコミットされます。
                &lt;p&gt;
                &lt;b&gt;注意 :        &lt;/b&gt;
                    ユーザーが更新操作をデータソースサーバーにコミットする場合は、Updateアクション、Deleteアクション、またはCreateアクションのURLを提供する必要があります。
                    データソースを更新するために使用するコードは、対応するアクション内に記述する必要があります。
                &lt;/p&gt;</value>
    <comment>By default, the update operation will be commit to the server once finishing editing.
                &lt;p&gt;
                    &lt;b&gt;Notices:&lt;/b&gt;
                    If the user wants to commit the update operation to the datasource server, the Update, Delete or Create action url should be provided.
                    And the corresponding codes used to update the datasource should be written in the corresponding action.
                &lt;/p&gt;</comment>
  </data>
  <data name="Editing_Description_Text6" xml:space="preserve">
    <value>もう１つのモードはBatchEditです。 ユーザーは複数の項目を更新、作成、または削除できます。
                これらの変更は、確認後に１回だけデータソースに対してコミットされます。
                これで、これらの変更はクライアント側のCollectionViewのcommitメソッドによってコミットできます。
                ユーザーは、ソート動作、ページング動作、またはフィルタ処理動作によってこれらをコミットすることもできます。
                &lt;p&gt;
                &lt;b&gt;注意 :        &lt;/b&gt;
                    このモードでは、BatchEditアクションURLを提供し、データソースの更新に使用される対応するコードを記述する必要があります。
                &lt;/p&gt;</value>
    <comment>The other mode is called BatchEdit. The user can update, create or remove multiple items.
                Once these modifications are confirmed, They could be commit to the data source only once. 
                Now these modifications can be commit by the commit method of CollectionView in client side.
                The user can also commit them by sorting, paging or filtering behavior.
                &lt;p&gt;
                    &lt;b&gt;Notices:&lt;/b&gt;
                     In this mode, the BatchEdit action url should be provided and the corresponding codes used to update the datasource should be written.
                &lt;/p&gt;</comment>
  </data>
  <data name="Editing_Description_Text7" xml:space="preserve">
    <value>Grid、Column、Rowオブジェクトの&lt;b&gt;IsReadOnly&lt;/b&gt;プロパティを使用して、Grid、Column、またはRowレベルで編集を無効にすることができます。 この例では、ID列を読み取り専用にします。</value>
    <comment>You can disable editing at the Grid, Column, or Row levels using the &lt;b&gt;IsReadOnly&lt;/b&gt; property of the
            Grid, Column, or Row objects. In this example, we make the ID column read-only.</comment>
  </data>
  <data name="Editing_Text0" xml:space="preserve">
    <value>編集</value>
    <comment>Editing</comment>
  </data>
  <data name="Filtering_Description_Text0" xml:space="preserve">
    <value>FlexGridは、&lt;b&gt;Filterable&lt;/b&gt;プロパティを使用したフィルタ処理をサポートします。 フィルタ処理を有効にするには、&lt;b&gt;Filterable((Sub(fl) .ColumnFilters(Sub(cfsb)...&lt;/b&gt;プロパティを設定します。</value>
    <comment>The FlexGrid supports filtering through the &lt;b&gt;Filterable&lt;/b&gt; property. To enable filtering, set the &lt;b&gt;Filterable(fl =&gt; fl.ColumnFilters()&lt;/b&gt; property.</comment>
  </data>
  <data name="Filtering_Description_Text1" xml:space="preserve">
    <value>この例では、ID、Country、Product、Color、Startに対するフィルタを作成し、入力コントロールからフィルタ値を取得します。</value>
    <comment>In this example, we create a filter for the ID, Country, Product, Color, Start and get the filter value from the input control.
        &lt;/p&gt;</comment>
  </data>
  <data name="Filtering_Text0" xml:space="preserve">
    <value>フィルタ処理</value>
    <comment>Filtering</comment>
  </data>
  <data name="Getting_Started_Text0" xml:space="preserve">
    <value>はじめに</value>
    <comment>Getting Started</comment>
  </data>
  <data name="Grouping_Desription_Text0" xml:space="preserve">
    <value>FlexGridは、クライアント側データのグループ化をサポートします。列に従ってデータをグループ化するためには、&lt;b&gt;GroupBy&lt;/b&gt;プロパティを列名に設定します。</value>
    <comment>FlexGrid supports grouping of client side data, set the &lt;b&gt;GroupBy&lt;/b&gt; property to a column name for grouping the data according to a column.</comment>
  </data>
  <data name="Grouping_Desription_Text1" xml:space="preserve">
    <value>内部的に、FlexGridはクライアント側の&lt;b&gt;IItemsSource&lt;/b&gt;インタフェースを使用してグループ化をサポートします。 クライアント側でグループ化を有効にするには、１つ以上の&lt;b&gt;GroupDescription&lt;/b&gt;オブジェクトを&lt;b&gt;itemsSource.groupDescriptions&lt;/b&gt;プロパティに追加します。 フィールドによってグリッドをグループ化するのは簡単です。対応するフィールド名を持つFlexGridBuilderのGroupByメソッドを呼び出します。 グリッドの&lt;b&gt;ShowGroups&lt;/b&gt;プロパティがtrue（デフォルト値）に設定されていることを確認します。
            &lt;b&gt;GroupDescription&lt;/b&gt;オブジェクトは柔軟であり、値またはグループ化関数に基づいてデータをグループ化できます。 次の例では、日付は年単位でグループ化し、金額は４つの範囲（5,000超、1,000から5,000、500から1,000、および500未満）にグループ化して、その他はすべて値でグループ化します。 メニューを使用して各グループ化の効果を確認してください。</value>
    <comment>Internally, FlexGrid supports grouping through the client side &lt;b&gt;IItemsSource&lt;/b&gt; interface. To enable grouping at client side, add one or more &lt;b&gt;GroupDescription&lt;/b&gt; objects to the
            &lt;b&gt;itemsSource.groupDescriptions&lt;/b&gt; property. It is easy to let the grid grouped by some field by calling the method GroupBy of FlexGridBuilder with the corresponding field name. And ensure that the grid's &lt;b&gt;ShowGroups&lt;/b&gt; property
            is set to true (the default value).
            &lt;b&gt;GroupDescription&lt;/b&gt; objects are flexible, allowing you to group data based on value or on grouping
            functions. The example below groups dates by year; amounts by range returning three ranges: over 5,000,
            1,000 to 5,000, 500 to 1,000, and under 500; and anything else by value. Use the menu to see the effects of each grouping.</comment>
  </data>
  <data name="Grouping_Desription_Text2" xml:space="preserve">
    <value>「Amount」列のグループ行に合計が表示されることに注意してください。 これは、列の&lt;b&gt;Aggregate&lt;/b&gt;プロパティを「Sum」に設定することで行われます。 列内の値を編集すると、集計は自動的に更新されます。</value>
    <comment>Notice that the "Amount" column displays the totals in the group rows. We do this by
            setting the column's &lt;b&gt;Aggregate&lt;/b&gt; property to "Sum." The aggregate is automatically
            updated when you edit the values in the column.</comment>
  </data>
  <data name="Grouping_Text0" xml:space="preserve">
    <value>グループ化</value>
    <comment>Grouping</comment>
  </data>
  <data name="Handling_Null_Values_Des_Text0" xml:space="preserve">
    <value>デフォルトで、FlexGridではstringタイプの列内には空の値を入力でき、その他のタイプの列には空、すなわちnull値は入力できません。</value>
    <comment>By default, FlexGrid allows you to enter empty values in columns of type string,
            and will not allow empty/null values in columns of any other type.</comment>
  </data>
  <data name="Handling_Null_Values_Des_Text1" xml:space="preserve">
    <value>この動作は、グリッド列の&lt;b&gt;IsRequired&lt;/b&gt;プロパティを使用して変更できます。
            &lt;b&gt;IsRequired&lt;/b&gt;プロパティをfalseに設定すると、その列のタイプにかかわらず、空の値をグリッドで入力できるようになります。 反対に、&lt;b&gt;IsRequired&lt;/b&gt;プロパティをtrueに設定すると、グリッドはstring列であっても空の値を許可しません。</value>
    <comment>You can change this behavior using the &lt;b&gt;IsRequired&lt;/b&gt; property on grid columns.
            If you set the &lt;b&gt;IsRequired&lt;/b&gt; property to false, the grid will allow you to
            enter empty values in that column, regardless of type. Conversely, if you set
            the &lt;b&gt;IsRequired&lt;/b&gt; property to true, the grid will not allow empty values
            even in string columns.</comment>
  </data>
  <data name="Handling_Null_Values_Des_Text2" xml:space="preserve">
    <value>&lt;b&gt;IsRequired&lt;/b&gt;をnullに設定すると、デフォルトの動作（nullはstring列でのみ許可）に戻ります。</value>
    <comment>Setting &lt;b&gt;IsRequired&lt;/b&gt; to null reverts to the default behavior (nulls allowed
            only in string columns).</comment>
  </data>
  <data name="Handling_Null_Values_Des_Text3" xml:space="preserve">
    <value>次のグリッドでは、デフォルトの動作に戻しています。 最初の列では&lt;b&gt;IsRequired&lt;/b&gt;をfalseに設定し、その他すべてではtrueに設定します。 不要なコンテンツを削除するには、空の文字列を入力するか、または単に［Delete］キーを押します。</value>
    <comment>The grid below reverts the default behavior. It sets &lt;b&gt;IsRequired&lt;/b&gt; to false
            for the first column, and to true for all others. You can delete content that
            is not required by entering an empty string or simply by pressing the delete
            key.</comment>
  </data>
  <data name="Handling_Null_Values_Text0" xml:space="preserve">
    <value>null値の処理</value>
    <comment>Handling null values</comment>
  </data>
  <data name="Overview_Description_Text0" xml:space="preserve">
    <value>これによって作成されるFlexGridは、デフォルトの動作を行います。たとえば、列の自動生成、列のソートと並べ替え、編集、クリップボードのサポートです。</value>
    <comment>This will create a FlexGrid with default behavior, which includes
            automatic column generation, column sorting and reordering, editing,
            and clipboard support.</comment>
  </data>
  <data name="Overview_Step1_Text0" xml:space="preserve">
    <value>ComponentOne ASP.NET MVCアプリケーションテンプレートを使用して、新しいMVCプロジェクトを作成します。</value>
    <comment>Create a new MVC project using the C1 ASP.NET MVC application template, in Visual Studio IDE.</comment>
  </data>
  <data name="Overview_Step2_Text0" xml:space="preserve">
    <value>プロジェクトに、コントローラおよび対応するビューを追加します。</value>
    <comment>Add a controller and the corresponding view to the project.</comment>
  </data>
  <data name="Overview_Step3_Text0" xml:space="preserve">
    <value>razor構文を使用して、ビューのFlexGridコントロールを初期化します。</value>
    <comment>Initialize the FlexGrid control in view using razor syntax.</comment>
  </data>
  <data name="Overview_Step4_Text0" xml:space="preserve">
    <value>（オプション）CSSを追加して、FlexGridコントロールの外観をカスタマイズします。</value>
    <comment>(Optional) Add an appropriate CSS to customize the appearance of FlexGrid control.</comment>
  </data>
  <data name="Overview_Step_Title_Text0" xml:space="preserve">
    <value>MVCアプリケーションでFlexGridコントロールの使用を開始する際の手順。</value>
    <comment>Steps for getting started with the FlexGrid control in MVC applications are as follows:</comment>
  </data>
  <data name="Paging_Description_Text0" xml:space="preserve">
    <value>FlexGridは、&lt;b&gt;Pager&lt;/b&gt;コントロールを使用したページングをサポートします。 ページングを有効にするには、&lt;b&gt;PageSize&lt;/b&gt;プロパティにページに表示する項目数を設定して、PagerコントロールをFlexGridにバインドします。</value>
    <comment>The FlexGrid supports paging through the &lt;b&gt;Pager&lt;/b&gt; control. To enable paging, set the &lt;b&gt;PageSize&lt;/b&gt; property to the number
            of items you want on each page, and use Pager control to bind this FlexGrid.</comment>
  </data>
  <data name="Paging_Description_Text1" xml:space="preserve">
    <value>この例では、&lt;b&gt;PageSize&lt;/b&gt;を設定して1ページに10項目を表示します。 Pagerコントロールを追加して、&lt;b&gt;Owner&lt;/b&gt;プロパティにFlexGridのIDを設定すると、ページ切り替えすることができます。</value>
    <comment>In this example, we set &lt;b&gt;PageSize&lt;/b&gt; to show 10 items per page. We add Pager control and set &lt;b&gt;Owner&lt;/b&gt; Property to the FlexGrid id,
            then we can switch pages.</comment>
  </data>
  <data name="Paging_Text0" xml:space="preserve">
    <value>ページング</value>
    <comment>Paging</comment>
  </data>
  <data name="Project_Description_Text0" xml:space="preserve">
    <value>このページでは、FlexGridコントロールの使用を開始する方法を説明します。</value>
    <comment>This page shows how to get started with ASP.NET MVC's FlexGrid controls.</comment>
  </data>
  <data name="Selection_Modes_Description_Text0" xml:space="preserve">
    <value>Excelと同様に、FlexGridではデフォルトでマウスまたはキーボードを使ってセルの範囲を選択できます。 &lt;b&gt;SelectionMode&lt;/b&gt;プロパティを使用すると、これを変更して、Row、Range of Rows、Non-Contiguous Rows（リストボックス内など）、Single Cell、Range of Cellsを選択するか、または選択を完全に無効にできます。</value>
    <comment>By default, FlexGrid allows you to select a range of cells with the mouse or keyboard,
            just like Excel. The &lt;b&gt;SelectionMode &lt;/b&gt; property allows you to change that so that you
            can select a Row, a Range of Rows, Non-Contiguous Rows (like in a List-Box), a Single Cell, a Range of Cells
            or disable selection altogether.</comment>
  </data>
  <data name="Selection_Modes_Description_Text1" xml:space="preserve">
    <value>この例では、ComboBoxコントロールから&lt;b&gt;SelectionMode&lt;/b&gt;を選択できます。</value>
    <comment>This example allows you to pick the &lt;b&gt;SelectionMode &lt;/b&gt; from a C1 ASP.NET MVC's ComboBox control.</comment>
  </data>
  <data name="Selection_Modes_Text0" xml:space="preserve">
    <value>選択モード</value>
    <comment>Selection Modes</comment>
  </data>
  <data name="Themes_Description_Text0" xml:space="preserve">
    <value>FlexGridの外観はCSSで定義されます。 デフォルトのテーマに加えて、プロのデザインによる12種類ほどのテーマが組み込まれており、すべてのComponentOne ASP.NET MVCコントロールの外観を統一感のある魅力的な見た目にカスタマイズできます。</value>
    <comment>The appearance of the FlexGrid is defined in CSS. In addition to the default theme, we
            include about a dozen professionally designed themes that customize the appearance of
            all C1 ASP.NET MVC controls to achieve a consistent, attractive look.</comment>
  </data>
  <data name="Themes_Description_Text1" xml:space="preserve">
    <value>この例では、グリッド要素に「custom-flex-grid」クラスを追加し、CSSルールを定義して、「custom-flex-grid」を持つすべてのグリッドに対して単純な「白黒、境界線なし」のテーマを作成します。</value>
    <comment>In this example, we add a "custom-flex-grid" class to the grid element and define some
            CSS rules to create a simple "black and white, no borders" theme for any grids that
            have the "custom-flex-grid" class.</comment>
  </data>
  <data name="Themes_Text0" xml:space="preserve">
    <value>テーマ</value>
    <comment>Themes</comment>
  </data>
  <data name="Trees_and_Hierarchical_Data_Des_Text0" xml:space="preserve">
    <value>グループ化に加えて、FlexGridは階層化データをサポートします。これは、サブ項目のリストを持つ項目があるデータのことです。 このタイプの階層構造はごく一般的なもので、通常はツリービューコントロールで表示されます。</value>
    <comment>In addition to grouping, FlexGrid supports hierarchical data, that is, data with items
            that have lists of subitems. This type of hierarchical structure is very common, and is
            usually displayed in a tree-view control.</comment>
  </data>
  <data name="Trees_and_Hierarchical_Data_Des_Text1" xml:space="preserve">
    <value>階層化データソースでFlexGridを使用するには、&lt;b&gt;ChildItemsPath&lt;/b&gt;プロパティを子要素が入っているデータ要素の名前に設定します。 グリッドは自動的にデータをスキャンし、ツリーを構築します。</value>
    <comment>To use FlexGrid with hierarchical data sources, set the &lt;b&gt;ChildItemsPath&lt;/b&gt; property
            to the name of the data element that contains the child elements. The grid automatically
            scans the data and builds the tree for you.</comment>
  </data>
  <data name="Trees_and_Hierarchical_Data_Text0" xml:space="preserve">
    <value>ツリーと階層化データ</value>
    <comment>Trees and Hierarchical Data</comment>
  </data>
  <data name="Group_By_Text0" xml:space="preserve">
    <value>グループ化</value>
    <comment>Group by</comment>
  </data>
  <data name="Result_Live_Text0" xml:space="preserve">
    <value>結果（ライブ）</value>
    <comment>Result(live)</comment>
  </data>
</root>