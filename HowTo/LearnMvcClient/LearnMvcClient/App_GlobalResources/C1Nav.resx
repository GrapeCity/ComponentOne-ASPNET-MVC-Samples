<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccordionTrees_Text1" xml:space="preserve">
    <value>Accordions are multi-pane panels that keep only one panel expanded
    at a time. They are commonly used for navigation.</value>
  </data>
  <data name="AccordionTrees_Text2" xml:space="preserve">
    <value>You can use the &lt;b&gt;TreeView&lt;/b&gt; control to implement accordions.</value>
  </data>
  <data name="AccordionTrees_Text3" xml:space="preserve">
    <value>Use CSS to customize the header display and to hide the
    collapse/expand glyphs, and make sure the &lt;b&gt;autoCollapse&lt;/b&gt;
    property is set to true (the default), so non-active panels
    are automatically collapsed.</value>
  </data>
  <data name="AccordionTrees_Text4" xml:space="preserve">
    <value>Use Custom CSS</value>
  </data>
  <data name="AccordionTrees_Text5" xml:space="preserve">
    <value>Ready</value>
  </data>
  <data name="AccordionTrees_Title" xml:space="preserve">
    <value>Accordion Trees</value>
  </data>
  <data name="Adding_Text1" xml:space="preserve">
    <value>To add nodes to a &lt;b&gt;TreeView&lt;/b&gt; control, add a new data item
    to the tree's &lt;b&gt;itemsSource&lt;/b&gt; array (at the proper position),
    then refresh the tree by calling the &lt;b&gt;loadTree&lt;/b&gt; method:</value>
  </data>
  <data name="Adding_Text2" xml:space="preserve">
    <value>New Node:</value>
  </data>
  <data name="Adding_Text3" xml:space="preserve">
    <value>Add Node:</value>
  </data>
  <data name="Adding_Text4" xml:space="preserve">
    <value>Before</value>
  </data>
  <data name="Adding_Text5" xml:space="preserve">
    <value>After</value>
  </data>
  <data name="Adding_Text6" xml:space="preserve">
    <value>Child</value>
  </data>
  <data name="Adding_Title" xml:space="preserve">
    <value>Adding Nodes</value>
  </data>
  <data name="AnotherAccordion_Text1" xml:space="preserve">
    <value>The control below looks like an Accordion but is really
    a TreeView with some CSS and a &lt;b&gt;formatItem&lt;/b&gt;
    event handler.</value>
  </data>
  <data name="AnotherAccordion_Text2" xml:space="preserve">
    <value>The tree automatically expands the selected item
    and collapses all others, and ensures only top-level
    nodes can be selected:</value>
  </data>
  <data name="AnotherAccordion_Text3" xml:space="preserve">
    <value>Selected item: &lt;b&gt;&lt;span id="selected"&gt;&lt;/span&gt;&lt;/b&gt;</value>
  </data>
  <data name="AnotherAccordion_Title" xml:space="preserve">
    <value>TreeView Accordion</value>
  </data>
  <data name="Architecture_Text1" xml:space="preserve">
    <value>The TreeView architecture is very simple, because it
    delegates a lot of the work to the browser's DOM.</value>
  </data>
  <data name="Architecture_Text2" xml:space="preserve">
    <value>The control is 100% data-bound. The &lt;b&gt;itemsSource&lt;/b&gt; property
    defines an array of data items that represent nodes and may
    contain child elements (as defined by the &lt;b&gt;childItemsPath&lt;/b&gt;
    property).
    When one of the binding properties change, the control populates
    its DOM by scanning the itemsSource array and creating DOM elements
    to represent the nodes.</value>
  </data>
  <data name="Architecture_Text3" xml:space="preserve">
    <value>There is no virtualization, so the number of DOM elements remains
    constant as the user scrolls the control, collapses or expands nodes.
    This is not a significant limitation since the TreeView supports
    lazy-loading, which allows you to load data as the user requests it
    (by expanding the nodes).</value>
  </data>
  <data name="Architecture_Text4" xml:space="preserve">
    <value>The TreeView has a &lt;b&gt;selectedItem&lt;/b&gt; property that gets or sets
    the data item in the &lt;b&gt;itemsSource&lt;/b&gt; array that is currently selected.
    It also has a &lt;b&gt;selectedNode&lt;/b&gt; property that gets or sets the tree
    node that wraps the current item. You can use the &lt;b&gt;selectedNode&lt;/b&gt;
    property to collapse, expand, or move the selection.
    You use the TreeView's &lt;b&gt;getNode&lt;/b&gt; method to get a reference to
    the node that represents a given data item.</value>
  </data>
  <data name="Architecture_Text5" xml:space="preserve">
    <value>To change the tree, you will normally change the &lt;b&gt;itemsSource&lt;/b&gt;
    array and call the &lt;b&gt;loadTree&lt;/b&gt; method to re-generate the nodes.
    The example below shows the performance of the TreeView when binding
    to sources of different sizes:</value>
  </data>
  <data name="Architecture_Text6" xml:space="preserve">
    <value>Levels:</value>
  </data>
  <data name="Architecture_Text7" xml:space="preserve">
    <value>Nodes/Level:</value>
  </data>
  <data name="Architecture_Text8" xml:space="preserve">
    <value>Bind Tree</value>
  </data>
  <data name="Architecture_Title" xml:space="preserve">
    <value>TreeView Architecture</value>
  </data>
  <data name="AutoGridLayout_Text1" xml:space="preserve">
    <value>Auto grid layout, as the name suggests, arranges the tiles in the tabular form automatically. An auto grid layout consists of groups which are rendered in the direction specified by the &lt;b&gt;orientation&lt;/b&gt; property. The property also defines the direction in which each group expands. You can also define the maximum number of rows or columns that each group can have in horizontal or vertical orientation respectively using &lt;b&gt;maxRowsOrCols&lt;/b&gt; property.</value>
  </data>
  <data name="AutoGridLayout_Text2" xml:space="preserve">
    <value>For instance, when orientation is set to horizontal, tiles are added row-wise until the maximum row count is reached. Once that limit is reached, the layout starts expanding horizontally by adding new columns one after the other. There is no limit to the number of columns that can be added in the horizontal orientation.</value>
  </data>
  <data name="AutoGridLayout_Text3" xml:space="preserve">
    <value>The auto grid layout also supports cell merging by spanning rows or columns through &lt;b&gt;rowSpan&lt;/b&gt; and &lt;b&gt;columnSpan&lt;/b&gt; properties of the tile  available in the designer.</value>
  </data>
  <data name="AutoGridLayout_Text4" xml:space="preserve">
    <value>The layout automatically positions the tiles in the DashboardLayout control. Each cell in the table can contain multiple controls, and these controls can be grouped together with the help of the group object.</value>
  </data>
  <data name="AutoGridLayout_Title" xml:space="preserve">
    <value>Auto Grid Layout</value>
  </data>
  <data name="BetweenTrees_Text1" xml:space="preserve">
    <value>Setting the &lt;b&gt;allowDrag&lt;/b&gt; property to true allows users
    to drag and drop nodes within the same &lt;b&gt;TreeView&lt;/b&gt;.</value>
  </data>
  <data name="BetweenTrees_Text2" xml:space="preserve">
    <value>To allow dragging and dropping nodes between different
    &lt;b&gt;TreeView&lt;/b&gt; controls, you must handle the &lt;b&gt;dragOver&lt;/b&gt;
    event and set the &lt;b&gt;cancel&lt;/b&gt; parameter to true if
    the operation is invalid, or to false if it is valid.</value>
  </data>
  <data name="BetweenTrees_Text3" xml:space="preserve">
    <value>allow dragging within trees</value>
  </data>
  <data name="BetweenTrees_Text4" xml:space="preserve">
    <value>allow dragging between trees</value>
  </data>
  <data name="BetweenTrees_Title" xml:space="preserve">
    <value>Drag and Drop Between Trees</value>
  </data>
  <data name="Changing_Text1" xml:space="preserve">
    <value>To refresh nodes after making changes to the items in the
    &lt;b&gt;itemsSource&lt;/b&gt; array, you may call the TreeView's
    &lt;b&gt;loadTree&lt;/b&gt; method. This will update the tree and
    will ensure the currently selected node is visible.</value>
  </data>
  <data name="Changing_Text2" xml:space="preserve">
    <value>If you want to refresh the content of a single node,
    however, it may be more efficient to change the node
    element directly without reloading the whole tree.</value>
  </data>
  <data name="Changing_Text3" xml:space="preserve">
    <value>The buttons below show both approaches:</value>
  </data>
  <data name="Changing_Text4" xml:space="preserve">
    <value>Change and reload the TreeView</value>
  </data>
  <data name="Changing_Text5" xml:space="preserve">
    <value>Change and update the TreeNode</value>
  </data>
  <data name="Changing_Title" xml:space="preserve">
    <value>Refreshing Nodes</value>
  </data>
  <data name="Checkboxes_Text1" xml:space="preserve">
    <value>Set the &lt;b&gt;showCheckboxes&lt;/b&gt; property to true and the TreeView will
    add checkboxes to each node.</value>
  </data>
  <data name="Checkboxes_Text2" xml:space="preserve">
    <value>When checkboxes are displayed, the TreeView manages their
    hierarchy so that when a checkbox is checked or cleared, the new
    value is automatically applied to all child nodes, and reflected
    on the state of the parent nodes.</value>
  </data>
  <data name="Checkboxes_Text3" xml:space="preserve">
    <value>When items are checked or unchecked, the &lt;b&gt;checkedItemsChanged&lt;/b&gt;
    event is raised, and the &lt;b&gt;checkedItems&lt;/b&gt; property is updated
    with a list of the items that are currently checked:</value>
  </data>
  <data name="Checkboxes_Text4" xml:space="preserve">
    <value>Check All</value>
  </data>
  <data name="Checkboxes_Text5" xml:space="preserve">
    <value>Uncheck All</value>
  </data>
  <data name="Checkboxes_Text6" xml:space="preserve">
    <value>Save State</value>
  </data>
  <data name="Checkboxes_Text7" xml:space="preserve">
    <value>Restore State</value>
  </data>
  <data name="Checkboxes_Title" xml:space="preserve">
    <value>Node Checkboxes</value>
  </data>
  <data name="ContextMenus_Text1" xml:space="preserve">
    <value>The TreeView below has a custom context menu.
    Right-click the tree to see it:</value>
  </data>
  <data name="ContextMenus_Text2" xml:space="preserve">
    <value>Option 1</value>
  </data>
  <data name="ContextMenus_Text3" xml:space="preserve">
    <value>Option 2</value>
  </data>
  <data name="ContextMenus_Text4" xml:space="preserve">
    <value>Option 3</value>
  </data>
  <data name="ContextMenus_Text5" xml:space="preserve">
    <value>Option 4</value>
  </data>
  <data name="ContextMenus_Title" xml:space="preserve">
    <value>TreeView with Context Menu</value>
  </data>
  <data name="CreatingProgrammatically_Text1" xml:space="preserve">
    <value>In some cases, you may want to add tabs to a TabPanel control programmatically rather than using HTML markup.</value>
  </data>
  <data name="CreatingProgrammatically_Text2" xml:space="preserve">
    <value>You can do this using the &lt;b&gt;tabs&lt;/b&gt; property, which provides access to the collection of tabs in the TabPanel.</value>
  </data>
  <data name="CreatingProgrammatically_Text3" xml:space="preserve">
    <value>You can also use the &lt;b&gt;tabs&lt;/b&gt; property to remove, modify, or reorder the tabs within the TabPanel.</value>
  </data>
  <data name="CreatingProgrammatically_Title" xml:space="preserve">
    <value>Creating TabPanels In Code</value>
  </data>
  <data name="CustomContent_Text1" xml:space="preserve">
    <value>You can customize the content of the TreeView nodes using the &lt;b&gt;formatItem&lt;/b&gt;
    event. The event handler parameters include the element that represents the node
    and the data item being rendered.</value>
  </data>
  <data name="CustomContent_Text2" xml:space="preserve">
    <value>The example below uses the &lt;b&gt;formatItem&lt;/b&gt; event to add a "new" badge to the
    right of new items on the tree.</value>
  </data>
  <data name="CustomContent_Title" xml:space="preserve">
    <value>Custom Node Content</value>
  </data>
  <data name="CustomTile_Text1" xml:space="preserve">
    <value>The tile could be customized in the DashboardLayout control. For a tile, there are three areas: Header, Toolbar and Content. All these areas can be customized via this event. The related dom elements or objects can be obtained in the event argument: headerElement, toolbar and contentElement. You can customize these areas by the &lt;b&gt;formatTile&lt;/b&gt; event.</value>
  </data>
  <data name="CustomTile_Title" xml:space="preserve">
    <value>Custom Tile</value>
  </data>
  <data name="DashboardLayouts_Text1" xml:space="preserve">
    <value>&lt;b&gt;DashboardLayout&lt;/b&gt; provides four types of layouts, namely Flow, AutoGrid, ManualGrid and Split. These layouts specify the arrangement of the tiles in different ways on the DashboardLayout control. Being able to choose layouts that fits screen requirements is the core feature of the control.</value>
  </data>
  <data name="DashboardLayouts_Title" xml:space="preserve">
    <value>Different layouts</value>
  </data>
  <data name="DashboardLayout_Text1" xml:space="preserve">
    <value>&lt;b&gt;DashboardLayout&lt;/b&gt; is a layout control that allows you to create dynamic dashboards for interactive data visualization. It allows you to organize and present data in a consolidated form with the help of images, grids, charts, maps, etc in different layouts. This makes it easy for you to monitor the presented information.</value>
  </data>
  <data name="DashboardLayout_Text2" xml:space="preserve">
    <value>The &lt;b&gt;DashboardLayout&lt;/b&gt; control acts as a container which lets you dynamically place controls within tiles also called child containers. These child containers can be arranged in four different types of layouts supported by the DashboardLayout control i.e. Flow, AutoGrid, ManualGrid and Split. The appropriate layout is attached to the DashboardLayout control to achieve the specific layout. The control lets you resize and rearrange these child containers at runtime to create an ideal workspace.</value>
  </data>
  <data name="DashboardLayout_Text3" xml:space="preserve">
    <value>Being able to choose layouts that fits screen requirements is the core feature of the control. Other built-in features include drag and drop, maximize and restore, and save and load layouts.</value>
  </data>
  <data name="DashboardLayout_Title" xml:space="preserve">
    <value>DashboardLayout Concepts</value>
  </data>
  <data name="Disabling_Text1" xml:space="preserve">
    <value>You can disable nodes using the &lt;b&gt;TreeNode&lt;/b&gt;'s &lt;b&gt;isDisabled&lt;/b&gt;
    property.</value>
  </data>
  <data name="Disabling_Text2" xml:space="preserve">
    <value>Disabled nodes cannot be selected using the mouse or keyboard.</value>
  </data>
  <data name="Disabling_Text3" xml:space="preserve">
    <value>Disable Selected Node</value>
  </data>
  <data name="Disabling_Text4" xml:space="preserve">
    <value>Enable All Nodes</value>
  </data>
  <data name="Disabling_Title" xml:space="preserve">
    <value>Disabled Nodes</value>
  </data>
  <data name="DragDrop_Text1" xml:space="preserve">
    <value>Set the &lt;b&gt;allowDragging&lt;/b&gt; property to true to allow users
    to drag nodes to new positions within the &lt;b&gt;TreeView&lt;/b&gt;.</value>
  </data>
  <data name="DragDrop_Text10" xml:space="preserve">
    <value>allow dropping into empty nodes</value>
  </data>
  <data name="DragDrop_Text2" xml:space="preserve">
    <value>When dragging is allowed, users may drag any node to any position
    within the tree. Specifically, nodes can be dragged to a position
    above, below, or into (as a child of) other nodes.</value>
  </data>
  <data name="DragDrop_Text3" xml:space="preserve">
    <value>You can customize this behavior by handling the &lt;b&gt;TreeView&lt;/b&gt;
    drag/drop events:</value>
  </data>
  <data name="DragDrop_Text4" xml:space="preserve">
    <value>&lt;b&gt;dragStart:&lt;/b&gt; Occurs when a drag/drop operation is about to start.
        You may examine the node about to be dragged and cancel the operation
        by setting the event's &lt;b&gt;cancel&lt;/b&gt; parameter to true.</value>
  </data>
  <data name="DragDrop_Text5" xml:space="preserve">
    <value>&lt;b&gt;dragOver:&lt;/b&gt; Occurs while the user drags the node over other nodes
        on the tree. You may examine the current target node and drop position
        and prevent the drop or modify its location setting the event's
        &lt;b&gt;cancel&lt;/b&gt; and &lt;b&gt;position&lt;/b&gt; parameters.</value>
  </data>
  <data name="DragDrop_Text6" xml:space="preserve">
    <value>&lt;b&gt;drop:&lt;/b&gt; Occurs when the user drops the node into its new location.
        You may examine the current target node and drop position and
        prevent the drop or modify its location setting the event's
        &lt;b&gt;cancel&lt;/b&gt; and &lt;b&gt;position&lt;/b&gt; parameters.</value>
  </data>
  <data name="DragDrop_Text7" xml:space="preserve">
    <value>&lt;b&gt;dragEnd:&lt;/b&gt; Occurs after the drag/drop operation is finished,
        even if it was canceled and the source node was not moved.</value>
  </data>
  <data name="DragDrop_Text8" xml:space="preserve">
    <value>allow dragging</value>
  </data>
  <data name="DragDrop_Text9" xml:space="preserve">
    <value>allow dragging parent nodes</value>
  </data>
  <data name="DragDrop_Title" xml:space="preserve">
    <value>Drag and Drop</value>
  </data>
  <data name="Editing_Text1" xml:space="preserve">
    <value>The &lt;b&gt;TreeView&lt;/b&gt; control provides editing support. Set the
    &lt;b&gt;isReadOnly&lt;/b&gt; property to false and users will be able to
    edit the content of the nodes by pressing the F2 key.</value>
  </data>
  <data name="Editing_Text2" xml:space="preserve">
    <value>Edits made to node contents are automatically applied to the
    items in the &lt;b&gt;itemsSource&lt;/b&gt; array using the properties
    specified by the &lt;b&gt;displayMemberPath&lt;/b&gt; property.</value>
  </data>
  <data name="Editing_Text3" xml:space="preserve">
    <value>You may customize the editing behavior using the following events:
    &lt;b&gt;nodeEditStarting&lt;/b&gt;, &lt;b&gt;nodeEditStarted&lt;/b&gt;,
    &lt;b&gt;nodeEditEnding&lt;/b&gt;, and &lt;b&gt;nodeEditEnded&lt;/b&gt;.</value>
  </data>
  <data name="Editing_Text4" xml:space="preserve">
    <value>In the example below, we enable editing only for nodes that
    contain no children. To edit, select a node and press F2:</value>
  </data>
  <data name="Editing_Title" xml:space="preserve">
    <value>Editing Nodes</value>
  </data>
  <data name="FlowLayout_Text1" xml:space="preserve">
    <value>When the flow layout is applied in the DashboardLayout control, it arranges child containers into either rows or columns, per the direction property. By default, the flow of items is wrapped at the control's edge, so when one column/row ends, another one automatically starts.</value>
  </data>
  <data name="FlowLayout_Title" xml:space="preserve">
    <value>Flow Layout</value>
  </data>
  <data name="HeterogeneousData_Text1" xml:space="preserve">
    <value>In most TreeView applications, the &lt;b&gt;displayMemberPath&lt;/b&gt;
    and &lt;b&gt;childItemsPath&lt;/b&gt; properties are set to strings that
    define the name of the property that should be displayed on
    the nodes and the name of the property that contains child
    items (the default values for these properties are 'header'
    and 'items').</value>
  </data>
  <data name="HeterogeneousData_Text2" xml:space="preserve">
    <value>In some applications, however, the names of these binding
    properties depends on the hierarchical level of the data.
    In these cases, you can use an array of names for either
    property.</value>
  </data>
  <data name="HeterogeneousData_Text3" xml:space="preserve">
    <value>The tree below is bound to a list of 'continent' items,
    each with a 'countries' member that contains a list of
    'country' items with a 'cities' member:</value>
  </data>
  <data name="HeterogeneousData_Title" xml:space="preserve">
    <value>Heterogeneous Data</value>
  </data>
  <data name="Images_Text1" xml:space="preserve">
    <value>Use the &lt;b&gt;imageMemberPath&lt;/b&gt; property to add images to nodes
    by specifying the name of a property on the data items that
    contains an image URL.</value>
  </data>
  <data name="Images_Text2" xml:space="preserve">
    <value>For example, some our sample items array have an "Image" property
    set to image URLs:</value>
  </data>
  <data name="Images_Title" xml:space="preserve">
    <value>Node Images</value>
  </data>
  <data name="Index_Text1" xml:space="preserve">
    <value>The &lt;b&gt;TreeView&lt;/b&gt; control shows hierarchical data. It enables
    users to collapse or expand nodes, select items, load, search,
    and edit data, and to use drag and drop gestures to re-organize
    the items if needed.</value>
  </data>
  <data name="Index_Text2" xml:space="preserve">
    <value>To use the &lt;b&gt;TreeView&lt;/b&gt; control, you will normally use the
    following three properties:</value>
  </data>
  <data name="Index_Text3" xml:space="preserve">
    <value>&lt;b&gt;itemsSource&lt;/b&gt; defines the array that contains the hierarchical data.
        Each item in the array contains information about a node and (optionally)
        an array of child nodes.</value>
  </data>
  <data name="Index_Text4" xml:space="preserve">
    <value>&lt;b&gt;displayMemberPath&lt;/b&gt; defines the name of the property in the items
        that contains the text to be displayed in the tree nodes. By default,
        this property is set to the string 'header'.</value>
  </data>
  <data name="Index_Text5" xml:space="preserve">
    <value>&lt;b&gt;childItemsPath&lt;/b&gt; defines the name of the property in the items that
        contains the array of child nodes. By default, this property is set to the
        string 'items'.</value>
  </data>
  <data name="Index_Text6" xml:space="preserve">
    <value>Once the tree is set up, use the &lt;b&gt;itemClicked&lt;/b&gt; or
    &lt;b&gt;selectedItemChanged&lt;/b&gt; events to track user actions and handle them
    with the &lt;b&gt;selectedItem&lt;/b&gt; property.</value>
  </data>
  <data name="Index_Text7" xml:space="preserve">
    <value>For example, the &lt;b&gt;TreeView&lt;/b&gt; below shows a hierarchical list of
    products. Users may expand nodes by clicking the collapsed icons,
    or by pressing the right-arrow key when a node is selected.</value>
  </data>
  <data name="Index_Title" xml:space="preserve">
    <value>C1 MVC TreeView</value>
  </data>
  <data name="InitialState_Text1" xml:space="preserve">
    <value>By default, the TreeView expands the first node at each
    level and collapsed all others when it is bound to some
    data:</value>
  </data>
  <data name="InitialState_Text2" xml:space="preserve">
    <value>If you select an item when the tree loads, it will
    automatically ensure the selected node is visible,
    expanding the tree and scrolling as needed.
    In this case, we selected the 'Solar Panel' item:</value>
  </data>
  <data name="InitialState_Text3" xml:space="preserve">
    <value>Use the &lt;b&gt;collapseToLevel&lt;/b&gt; method to collapse or expand
    the tree to a given level when it loads. For example, the
    trees below start totally collapsed and totally expanded:</value>
  </data>
  <data name="InitialState_Title" xml:space="preserve">
    <value>Initial State</value>
  </data>
  <data name="InitialState_Title1" xml:space="preserve">
    <value>Selecting a default item</value>
  </data>
  <data name="InitialState_Title2" xml:space="preserve">
    <value>Collapsing to a given Level</value>
  </data>
  <data name="LazyLoading_Text1" xml:space="preserve">
    <value>Lazy loading is useful when you are dealing with large hierarchical
    data sources and would like to avoid the delays involved in loading
    the entire data set at once.</value>
  </data>
  <data name="LazyLoading_Text2" xml:space="preserve">
    <value>The &lt;b&gt;TreeView&lt;/b&gt; control makes lazy-loading super easy. Only two
    steps are required:</value>
  </data>
  <data name="LazyLoading_Text3" xml:space="preserve">
    <value>Set the &lt;b&gt;items&lt;/b&gt; property in the parent node data item to an
        empty array.</value>
  </data>
  <data name="LazyLoading_Text4" xml:space="preserve">
    <value>Set the &lt;b&gt;TreeView's&lt;/b&gt; &lt;b&gt;lazyLoadFunction&lt;/b&gt; property to a
        function to be called when the user expands the node. This function
        takes two parameters: the parent node and a callback function to be
        invoked when the data becomes available.</value>
  </data>
  <data name="LazyLoading_Text5" xml:space="preserve">
    <value>The tree in example below starts with three lazy-loaded nodes.
    When you expand them, the &lt;b&gt;lazyLoadFunction&lt;/b&gt; is invoked.
    The function uses a timeout to simulate an http delay and
    returns data for three child nodes, one of which is also a
    lazy-loaded node.</value>
  </data>
  <data name="LazyLoading_Title" xml:space="preserve">
    <value>Lazy-Loading Nodes</value>
  </data>
  <data name="LazyOdata_Text1" xml:space="preserve">
    <value>This example shows how you can use the &lt;b&gt;TreeView&lt;/b&gt; control to
    display hierarchical data from OData sources.</value>
  </data>
  <data name="LazyOdata_Text2" xml:space="preserve">
    <value>The sample starts by loading the Northwind employees table. When the
    data is loaded, the code adds an "Orders" empty array to each employee.
    The &lt;b&gt;lazyLoadFunction&lt;/b&gt; is used to load the orders when an employee
    node is expanded.</value>
  </data>
  <data name="LazyOdata_Text3" xml:space="preserve">
    <value>The orders table also adds an "Order_Details" empty array to each
    order. The &lt;b&gt;lazyLoadFunction&lt;/b&gt; is used to load the order details
    when an order node is expanded.</value>
  </data>
  <data name="LazyOdata_Title" xml:space="preserve">
    <value>Lazy-Loading and OData</value>
  </data>
  <data name="MainProperties_Text1" xml:space="preserve">
    <value>In addition to the data-binding properties that define the
    TreeView content, the control provides several properties that
    customize its behavior.</value>
  </data>
  <data name="MainProperties_Text2" xml:space="preserve">
    <value>This sample shows the effect of some of these properties:</value>
  </data>
  <data name="MainProperties_Text3" xml:space="preserve">
    <value>Collapse All</value>
  </data>
  <data name="MainProperties_Text4" xml:space="preserve">
    <value>Expand All</value>
  </data>
  <data name="MainProperties_Title" xml:space="preserve">
    <value>TreeView Properties</value>
  </data>
  <data name="ManualGridLayout_Text1" xml:space="preserve">
    <value>Manual grid layout, as the name suggests, arranges the tiles in the tabular form in the specified manner. The layout is similar to auto grid layout except the fact that you can specify the row and column numbers where a particular tile should be positioned.</value>
  </data>
  <data name="ManualGridLayout_Text2" xml:space="preserve">
    <value>Position of the tiles in the manual grid layout is specified using the Row and Column properties. Each cell in the manual grid layout can contain multiple controls, and these controls can be grouped together.</value>
  </data>
  <data name="ManualGridLayout_Title" xml:space="preserve">
    <value>Manual Grid Layout</value>
  </data>
  <data name="NavigationTrees_Text1" xml:space="preserve">
    <value>The simplest and most common use for the TreeView control is navigation.
    The &lt;b&gt;TreeView&lt;/b&gt;'s hierarchical structure and auto-search functionality
    make it easy for users to drill-down and find the items they are
    interested in.</value>
  </data>
  <data name="NavigationTrees_Text2" xml:space="preserve">
    <value>You can use the &lt;b&gt;selectedItemChanged&lt;/b&gt; or &lt;b&gt;itemClicked&lt;/b&gt; events
    for navigation. The difference is that &lt;b&gt;selectedItemChanged&lt;/b&gt; occurs
    when the user moves the selection with the keyboard, and &lt;b&gt;itemClicked&lt;/b&gt;
    occurs when the user clicks an item or presses the Enter key.</value>
  </data>
  <data name="NavigationTrees_Text3" xml:space="preserve">
    <value>This example uses the &lt;b&gt;itemClicked&lt;/b&gt; event:</value>
  </data>
  <data name="NavigationTrees_Text4" xml:space="preserve">
    <value>Ready</value>
  </data>
  <data name="NavigationTrees_Title" xml:space="preserve">
    <value>Navigation Trees</value>
  </data>
  <data name="Nodes_Text1" xml:space="preserve">
    <value>In most cases, you can work with a TreeView using only its
    data-binding and selection properties, and the original
    data items bound to the tree.</value>
  </data>
  <data name="Nodes_Text10" xml:space="preserve">
    <value>&lt;b&gt;index&lt;/b&gt;: Gets the index of this node in the node collection
        that contains it.</value>
  </data>
  <data name="Nodes_Text11" xml:space="preserve">
    <value>&lt;b&gt;level&lt;/b&gt;: Gets the node's level in the outline structure.
        Top level nodes have level zero.</value>
  </data>
  <data name="Nodes_Text12" xml:space="preserve">
    <value>&lt;b&gt;nodes&lt;/b&gt;: Gets an array containing the node's child nodes.</value>
  </data>
  <data name="Nodes_Text13" xml:space="preserve">
    <value>&lt;b&gt;previous, next, previousSibling, nextSibling&lt;/b&gt;:
        Get references to adjacent nodes on the tree, optionally excluding
        collapsed or non-sibling nodes.</value>
  </data>
  <data name="Nodes_Text14" xml:space="preserve">
    <value>&lt;b&gt;isChecked, isCollapsed, isDisabled:&lt;/b&gt; Get or set values that
        change the state of the node.</value>
  </data>
  <data name="Nodes_Text15" xml:space="preserve">
    <value>For example, click the button below to scan the &lt;i&gt;visible&lt;/i&gt;
    nodes on the TreeView. Try expanding and collapsing some
    nodes to see the difference when you click the button:</value>
  </data>
  <data name="Nodes_Text16" xml:space="preserve">
    <value>Scan Visible Nodes</value>
  </data>
  <data name="Nodes_Text17" xml:space="preserve">
    <value>Visible Nodes:</value>
  </data>
  <data name="Nodes_Text2" xml:space="preserve">
    <value>There are a few scenarios where you may need access to
    properties of the &lt;b&gt;TreeNode&lt;/b&gt; objects that make up
    the actual tree.</value>
  </data>
  <data name="Nodes_Text3" xml:space="preserve">
    <value>You can get the &lt;b&gt;TreeNode&lt;/b&gt; that corresponds to a given
    data item by calling the TreeView's &lt;b&gt;getNode&lt;/b&gt; method,
    or use the &lt;b&gt;nodes&lt;/b&gt; property to get the collection of
    root nodes on the TreeView.</value>
  </data>
  <data name="Nodes_Text4" xml:space="preserve">
    <value>Once you have a node, you can use its properties and methods
    to inspect or modify the tree. These properties and methods
    include:</value>
  </data>
  <data name="Nodes_Text5" xml:space="preserve">
    <value>&lt;b&gt;dataItem&lt;/b&gt;: Gets the item in the data source that is
        bound to this node.</value>
  </data>
  <data name="Nodes_Text6" xml:space="preserve">
    <value>&lt;b&gt;element&lt;/b&gt;: Gets the HTML element that represents this
        node.</value>
  </data>
  <data name="Nodes_Text7" xml:space="preserve">
    <value>&lt;b&gt;ensureVisible&lt;/b&gt;: Expands parent nodes and scrolls the
        TreeView as needed to ensure the node is currently visible.</value>
  </data>
  <data name="Nodes_Text8" xml:space="preserve">
    <value>&lt;b&gt;select&lt;/b&gt;: Selects the node and ensures it is visible.</value>
  </data>
  <data name="Nodes_Text9" xml:space="preserve">
    <value>&lt;b&gt;parentNode&lt;/b&gt;: Gets a reference to the node's parent node.</value>
  </data>
  <data name="Nodes_Title" xml:space="preserve">
    <value>TreeView Nodes</value>
  </data>
  <data name="Reloading_Text1" xml:space="preserve">
    <value>The TreeView's &lt;b&gt;lazyLoadFunction&lt;/b&gt; property allows you to
    create nodes that are loaded only when the node is expanded.</value>
  </data>
  <data name="Reloading_Text2" xml:space="preserve">
    <value>This can be used to improve performance in cases where data is
    loaded asynchronously.</value>
  </data>
  <data name="Reloading_Text3" xml:space="preserve">
    <value>By default, lazy nodes load their data only once, when the node
    is expanded for the first time. This sample shows how you can
    change that behavior for selected nodes causing them to re-load
    their data whenever they are expanded. The sample does this by:</value>
  </data>
  <data name="Reloading_Text4" xml:space="preserve">
    <value>Clearing the node's lazy-loaded data when the node is
        collapsed, and</value>
  </data>
  <data name="Reloading_Text5" xml:space="preserve">
    <value>Re-binding the tree to remove the old nodes.</value>
  </data>
  <data name="Reloading_Title" xml:space="preserve">
    <value>Re-loading Lazy-Loaded Nodes</value>
  </data>
  <data name="Removing_Text1" xml:space="preserve">
    <value>To remove nodes from a &lt;b&gt;TreeView&lt;/b&gt; control, remove the data
    item from the tree's &lt;b&gt;itemsSource&lt;/b&gt; array, then refresh the
    tree by calling the &lt;b&gt;loadTree&lt;/b&gt; method:</value>
  </data>
  <data name="Removing_Text2" xml:space="preserve">
    <value>Remove Selected Node</value>
  </data>
  <data name="Removing_Title" xml:space="preserve">
    <value>Removing Nodes</value>
  </data>
  <data name="Rtl_Text1" xml:space="preserve">
    <value>Some languages render content from the right to the left of the page
    (Arabic and Hebrew are typical examples) . HTML accommodates this
    with the 'dir' attribute. Setting 'dir' to 'rtl' on any element
    causes the element's content to flow from right to left.</value>
  </data>
  <data name="Rtl_Text2" xml:space="preserve">
    <value>The &lt;b&gt;TreeView&lt;/b&gt; supports this automatically. If the element hosting
    the tree has the 'dir' attribute set to 'rtl', the tree will render with
    nodes extending from right to left. You don't have to set any properties
    on the control.</value>
  </data>
  <data name="Rtl_Text3" xml:space="preserve">
    <value>Note that the 'dir' attribute value is inherited, so if you set it on the
    body tag for example, the entire page will be rendered from right to left,
    including the tree.</value>
  </data>
  <data name="Rtl_Text4" xml:space="preserve">
    <value>Note also that CSS has a 'direction' attribute that performs the same
    function as the 'dir' element attribute. The 'dir' attribute is generally
    considered more appropriate for several reasons, including the fact that
    it can be used in CSS rules.</value>
  </data>
  <data name="Rtl_Text5" xml:space="preserve">
    <value>Right to Left Layout</value>
  </data>
  <data name="Rtl_Text6" xml:space="preserve">
    <value>This is some regular content, followed by a &lt;b&gt;TreeView&lt;/b&gt;:</value>
  </data>
  <data name="Rtl_Title" xml:space="preserve">
    <value>RTL Support</value>
  </data>
  <data name="SaveLoadLayout_Text1" xml:space="preserve">
    <value>The DashboardLayout control provides a public API to save and load the layout to local storage in JSON format through the &lt;b&gt;saveLayout&lt;/b&gt; and &lt;b&gt;loadLayout&lt;/b&gt; methods. This feature is helpful if you need to save a particular layout and load, or to provide an option to users that may need to change layout and save it to load later.</value>
  </data>
  <data name="SaveLoadLayout_Title" xml:space="preserve">
    <value>Save and Load Layout</value>
  </data>
  <data name="Searching_Text1" xml:space="preserve">
    <value>Searching TreeViews is not trivial because of their hierarchical nature.
    Nodes typically reflect a context defined by in part by their parent
    nodes but also by additional content associated with the node.</value>
  </data>
  <data name="Searching_Text2" xml:space="preserve">
    <value>For example, if a user searched the TreeView below for "Electronics",
    you may or may not want to include the child nodes in the results.
    Furthermore, if items contained detailed descriptions, you might want
    to add keywords to help in the search. So if a user typed for example
    "beard", you would probably want the "Trimmers/Shavers" node to be
    selected.</value>
  </data>
  <data name="Searching_Text3" xml:space="preserve">
    <value>The AutoComplete control provides a good way to implement a search
    box to be used with the TreeView. In this sample, we build a flat
    searchArray with the full node paths and keywords and use that as
    an itemsSource for searching through the TreeView.</value>
  </data>
  <data name="Searching_Text4" xml:space="preserve">
    <value>In addition to the 'itemsSource'and 'displayMemberPath' properties,
    we use the 'searchMemberPath' property to specify the name of the
    field that contains the keywords to include in the search.
    For example, try typing 'collect' or 'food' in the search box:</value>
  </data>
  <data name="Searching_Text5" xml:space="preserve">
    <value>Search:</value>
  </data>
  <data name="Searching_Title" xml:space="preserve">
    <value>Searching TreeViews</value>
  </data>
  <data name="SplitLayout_Text1" xml:space="preserve">
    <value>The split layout is helpful when we want to add the tiles in different orientations for different groups. It enables the users to have nested groups where in each group can have a different orientation. The group can either consist of another or a tile. Each tile can render any MVC or HTML control. The order in which the groups are rendered is determined by the &lt;b&gt;orientation&lt;/b&gt; property. When the orientation is set to Horizontal, the groups or tiles are rendered horizontally and when the orientation is set to Vertical, then the groups or tiles are rendered vertically.</value>
  </data>
  <data name="SplitLayout_Text2" xml:space="preserve">
    <value>The split layout divides the dashboard into multiple section where in you can add multiple tiles to the layout.</value>
  </data>
  <data name="SplitLayout_Title" xml:space="preserve">
    <value>Split Layout</value>
  </data>
  <data name="StylingCSS_Text1" xml:space="preserve">
    <value>You can customize the appearance of the TreeView using CSS.</value>
  </data>
  <data name="StylingCSS_Text2" xml:space="preserve">
    <value>This example changes the collapse/expand icons, uses different
    font sizes depending on node level, and adds a vertical bar to
    the left of the level one nodes.</value>
  </data>
  <data name="StylingCSS_Text3" xml:space="preserve">
    <value>Use Custom CSS</value>
  </data>
  <data name="StylingCSS_Title" xml:space="preserve">
    <value>Styling and CSS</value>
  </data>
  <data name="TabPanelAccessibility_Text1" xml:space="preserve">
    <value>The TabPanel implements WAI-ARIA accessibility guidelines. All tab elements have the proper role attributes as well as all applicable ARIA attributes.</value>
  </data>
  <data name="TabPanelAccessibility_Text2" xml:space="preserve">
    <value>The example below assigns unique IDs to the tab headers and panes, which the TabPanel automatically uses to generate "aria-controls" and "aria-labelledby" attributes.</value>
  </data>
  <data name="TabPanelAccessibility_Text3" xml:space="preserve">
    <value>The example also adds a "wj-state-active" class to the "America" pane in markup to define the tab that is initially selected. Without that, the first tab would have been selected by default.</value>
  </data>
  <data name="TabPanelAccessibility_Text4" xml:space="preserve">
    <value>Finally, the example shows the effect of the &lt;b&gt;autoSwitch&lt;/b&gt; property, which affects how the control handles the tab and cursor keys. For a detailed discussion of this topic, please see the &lt;a href="https://www.w3.org/TR/wai-aria-practices/#kbd_selection_follows_focus" target="_blank"&gt;W3C ARIA practices&lt;/a&gt; and &lt;a href="https://simplyaccessible.com/article/danger-aria-tabs/" target="_blank"&gt;SimplyAccessible articles.&lt;/a&gt;</value>
  </data>
  <data name="TabPanelAccessibility_Title" xml:space="preserve">
    <value>TabPanel Accessibility</value>
  </data>
  <data name="TabPanelDetachedPanels_Text1" xml:space="preserve">
    <value>The TabPanel has a built-in panel that shows the content of the selected tab. In some cases, you may want to display the content in a different element.</value>
  </data>
  <data name="TabPanelDetachedPanels_Text2" xml:space="preserve">
    <value>To do that, hide the built-in content element and use the &lt;b&gt;OnClientSelectedIndexChanged&lt;/b&gt; event to update the content.</value>
  </data>
  <data name="TabPanelDetachedPanels_Title" xml:space="preserve">
    <value>Detached Panels</value>
  </data>
  <data name="TabPanelDisabledInvisibleTabs_Text1" xml:space="preserve">
    <value>You can disable or hide individual tabs using the Tab's &lt;b&gt;isDisabled&lt;/b&gt; and &lt;b&gt;isVisible&lt;/b&gt; properties.</value>
  </data>
  <data name="TabPanelDisabledInvisibleTabs_Text2" xml:space="preserve">
    <value>Invisible and disabled tabs cannot be selected by the user.</value>
  </data>
  <data name="TabPanelDisabledInvisibleTabs_Title" xml:space="preserve">
    <value>Disabled and Invisible Tabs</value>
  </data>
  <data name="TabPanelHostC1Controls_Text1" xml:space="preserve">
    <value>One of the main benefits of the TabPanel control is that it automatically updates any C1 controls it contains when a new tab is selected.</value>
  </data>
  <data name="TabPanelHostC1Controls_Text2" xml:space="preserve">
    <value>When using other tab controls, you must add code to refresh any C1 controls contained in the tabs.</value>
  </data>
  <data name="TabPanelHostC1Controls_Title" xml:space="preserve">
    <value>Hosting C1 Controls</value>
  </data>
  <data name="TabPanelMarkup_Text1" xml:space="preserve">
    <value>The markup used to initialize TabPanel controls consists of one element per tab, each with two children: the tab header and the tab content.</value>
  </data>
  <data name="TabPanelMarkup_Text2" xml:space="preserve">
    <value>We suggest you use anchor elements (tag a) for the tab headers because they are semantically more meaningful than plain div elements.</value>
  </data>
  <data name="TabPanelMarkup_Text3" xml:space="preserve">
    <value>In this example, we added a "wj-state-active" class to the "America" pane markup. That defines the tab that is initially selected. Alternatively, we could have set the TabPanel's &lt;b&gt;selectedIndex&lt;/b&gt; property.</value>
  </data>
  <data name="TabPanelMarkup_Title" xml:space="preserve">
    <value>TabPanel Markup</value>
  </data>
  <data name="TabPanelRightToLeft_Text1" xml:space="preserve">
    <value>Some languages render content from the right to the left of the page(Arabic and Hebrew are typical examples). HTML accommodates this with the 'dir' attribute. Setting 'dir' to 'rtl' on any element causes the element's content to flow from right to left.</value>
  </data>
  <data name="TabPanelRightToLeft_Text2" xml:space="preserve">
    <value>The TabPanel supports this automatically. If the element hosting the control has the 'dir' attribute set to 'rtl', the panel will render with tabs aligned from right to left. You don't have to set any properties on the control.</value>
  </data>
  <data name="TabPanelRightToLeft_Text3" xml:space="preserve">
    <value>Note that the 'dir' attribute value is inherited, so if you set it on the body tag for example, the entire page will be rendered from right to left, including the TabPanel.</value>
  </data>
  <data name="TabPanelRightToLeft_Text4" xml:space="preserve">
    <value>Note also that CSS has a 'direction' attribute that performs the same function as the 'dir' element attribute. The 'dir' attribute is generally considered more appropriate for several reasons, including the fact that it can be used in CSS rules.</value>
  </data>
  <data name="TabPanelRightToLeft_Title" xml:space="preserve">
    <value>TabPanel Right to Left</value>
  </data>
  <data name="TabPanelStyling_Text1" xml:space="preserve">
    <value>The TabPanel control has a simple layout, which makes it easy to style using CSS. For example, tabs appear above the content by default, but you can use CSS to change their position and show the below or vertically stacked, to the left or to the right of the content.</value>
  </data>
  <data name="TabPanelStyling_Text2" xml:space="preserve">
    <value>You can also choose whether or not to use animation when switching tabs.</value>
  </data>
  <data name="TabPanelStyling_Title" xml:space="preserve">
    <value>Styling and CSS</value>
  </data>
  <data name="TabPanel_Text1" xml:space="preserve">
    <value>The TabPanel control enables content organization at a high level, such as switching between views, data sets, or functional aspects of an application.</value>
  </data>
  <data name="TabPanel_Text2" xml:space="preserve">
    <value>Tabs are presented as a single row above their associated content. Tab headers succinctly describe the content within.</value>
  </data>
  <data name="TabPanel_Text3" xml:space="preserve">
    <value>Tabs can be selected with the mouse or keyboard, and automatically update the content to reflect the current selection.</value>
  </data>
  <data name="TabPanel_Text4" xml:space="preserve">
    <value>Each tab consists of a header element (always visible) and a pane element that contains the tab content. The pane element is visible when the corresponding header is selected with the mouse or keyboard.</value>
  </data>
  <data name="TabPanel_Title" xml:space="preserve">
    <value>TabPanel Concepts</value>
  </data>
  <data name="Export" xml:space="preserve">
    <value>Export</value>
  </data>
  <data name="Settings" xml:space="preserve">
    <value>Settings</value>
  </data>
  <data name="Countrywise" xml:space="preserve">
    <value>Countrywise Sales for {0}</value>
  </data>
  <data name="CustomTile_Cancel" xml:space="preserve">
    <value>Cancel</value>
  </data>
  <data name="CustomTile_ChartType" xml:space="preserve">
    <value>ChartType</value>
  </data>
  <data name="CustomTile_OK" xml:space="preserve">
    <value>OK</value>
  </data>
  <data name="KPIs" xml:space="preserve">
    <value>KPIs for {0}</value>
  </data>
  <data name="SalesDashboard" xml:space="preserve">
    <value>Sales Dashboard for {0}</value>
  </data>
  <data name="Share_Header1" xml:space="preserve">
    <value>Country</value>
  </data>
  <data name="Share_Text1" xml:space="preserve">
    <value>Sales</value>
  </data>
  <data name="Share_Text2" xml:space="preserve">
    <value>Expenses</value>
  </data>
  <data name="Share_Text3" xml:space="preserve">
    <value>Profit</value>
  </data>
  <data name="CostBudget" xml:space="preserve">
    <value>Cost Budgeting for {0}</value>
  </data>
  <data name="SplitLayout_Text0" xml:space="preserve">
    <value>Quarter Sales ({0})</value>
  </data>
  <data name="Share_Header2" xml:space="preserve">
    <value>Last 12 Months</value>
  </data>
  <data name="Share_Header3" xml:space="preserve">
    <value>Current Year(mil.)</value>
  </data>
  <data name="Share_Header4" xml:space="preserve">
    <value>Status</value>
  </data>
  <data name="Share_Text4" xml:space="preserve">
    <value>Sales Trend Line</value>
  </data>
  <data name="Share_Text5" xml:space="preserve">
    <value>Budget</value>
  </data>
  <data name="Share_Text6" xml:space="preserve">
    <value>in millions</value>
  </data>
</root>